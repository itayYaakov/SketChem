!(function () {
    "use strict";
    (Kekule.Calculator = {}),
        (Kekule.Calculator.Utils = {
            _instanceMaxIndex: 0,
            generateUid: function () {
                return (
                    ++Kekule.Calculator.Utils._instanceMaxIndex,
                    "Kekule.Calculator." + Kekule.Calculator.Utils._instanceMaxIndex
                );
            },
        }),
        (Kekule.Calculator.getWorkerBasePath = function () {
            var e = Kekule.isUsingMinJs() ? "workers/" : "calculation/workers/";
            return (e = Kekule.getScriptPath() + e);
        }),
        (Kekule.Calculator.Base = Class.create(ObjectEx, {
            CLASS_NAME: "Kekule.Calculator.Base",
            WORKER_SHARED_COUNT_FIELD: "__$workerSharedCount$__",
            initialize: function () {
                this.setPropStoreFieldValue("uid", this._generateUid()), this.tryApplySuper("initialize");
            },
            initProperties: function () {
                this.defineProp("async", { dataType: DataType.BOOL }),
                    this.defineProp("worker", { dataType: DataType.OBJECT, setter: null }),
                    this.defineProp("uid", { dataType: DataType.STRING, setter: null });
            },
            initPropValues: function () {
                this.tryApplySuper("initPropValues"),
                    this.setAsync(!0),
                    (this.reactWorkerMessageBind = this.reactWorkerMessage.bind(this)),
                    (this.reactWorkerErrorBind = this.reactWorkerError.bind(this));
            },
            doFinalize: function () {
                this.finalizeWorker(), this.tryApplySuper("doFinalize");
            },
            _generateUid: function () {
                return Kekule.Calculator.Utils.generateUid();
            },
            isWorkerShared: function () {
                return !1;
            },
            _incWorkerSharedCount: function (e) {
                if (this.isWorkerShared()) {
                    var r = e[this.WORKER_SHARED_COUNT_FIELD] || 0;
                    ++r, (e[this.WORKER_SHARED_COUNT_FIELD] = r);
                }
            },
            _decWorkerSharedCount: function (e) {
                if (this.isWorkerShared()) {
                    var r = e[this.WORKER_SHARED_COUNT_FIELD] || 0;
                    r && --r, (e[this.WORKER_SHARED_COUNT_FIELD] = r);
                }
            },
            _isWorkerInSharingState: function (e) {
                return this.isWorkerShared() && (e[this.WORKER_SHARED_COUNT_FIELD] || 0) > 0;
            },
            getWorkerBasePath: function () {
                return Kekule.Calculator.getWorkerBasePath();
            },
            execute: function (e, r, t) {
                if (
                    ((this._doneCallback = e),
                    (this._errCallback = r),
                    (this._msgCallback = t),
                    this.getAsync() && this.isWorkerSupported() && this.fetchWorker())
                ) {
                    var i = this.getWorker();
                    this._incWorkerSharedCount(i), this._installWorkerEventReceiver(i), this.workerStartCalc(i);
                } else {
                    var a, n;
                    try {
                        n = this.executeSync(e);
                    } catch (e) {
                        a = e;
                    }
                    a ? (Kekule.error(a), this.error(a)) : n && (a ? this.error(a) : this.done());
                }
            },
            executeSync: function (e) {
                this._doneCallback = e;
                var r = this.doExecuteSync(e);
                return r && this.done(), r;
            },
            doExecuteSync: function (e) {},
            error: function (e) {
                Kekule.error(e), this._errCallback && this._errCallback(e);
            },
            done: function () {
                this._doneCallback && this._doneCallback.apply(this, arguments),
                    this.getWorker() && this.workerJobDone();
            },
            halt: function () {
                var e = this.getWorker();
                e && (e.terminate(), this.error(Kekule.$L("ErrorMsg.CALC_TERMINATED_BY_USER")));
            },
            isWorkerSupported: function () {
                return Kekule.BrowserFeature.workers;
            },
            fetchWorker: function () {
                var e = this.getWorker();
                return e || (e = this.createWorker()), e;
            },
            createWorker: function () {
                if (this.isWorkerSupported()) {
                    var e = this.getWorkerScriptFile();
                    if (e) {
                        var r = new Worker(e);
                        return this.setPropStoreFieldValue("worker", r), r;
                    }
                }
            },
            _installWorkerEventReceiver: function (e) {
                e.addEventListener("message", this.reactWorkerMessageBind),
                    e.addEventListener("error", this.reactWorkerErrorBind);
            },
            _uninstallWorkerEventReceiver: function (e) {
                e.removeEventListener("message", this.reactWorkerMessageBind),
                    e.removeEventListener("error", this.reactWorkerErrorBind);
            },
            getWorkerScriptFile: function () {
                return null;
            },
            importWorkerScriptFile: function (e) {
                this.postWorkerMessage({ type: "importScript", url: e });
            },
            postWorkerMessage: function (e) {
                var r = Object.extend({ uid: this.getUid() }, e),
                    t = this.getWorker();
                t && t.postMessage(r);
            },
            reactWorkerMessage: function (e) {
                return e.data.uid === this.getUid()
                    ? (this._msgCallback && this._msgCallback(e.data), this.doReactWorkerMessage(e.data, e))
                    : null;
            },
            doReactWorkerMessage: function (e, r) {},
            reactWorkerError: function (e) {
                Kekule.error(e.message), this.error(e.message);
            },
            workerStartCalc: function (e) {},
            workerJobDone: function () {
                var e = this.getWorker();
                e && (this._uninstallWorkerEventReceiver(e), this._decWorkerSharedCount(e));
            },
            finalizeWorker: function () {
                var e = this.getWorker();
                e && (this._isWorkerInSharingState(e) || e.terminate(), this.setPropStoreFieldValue("worker", null));
            },
        })),
        (Kekule.Calculator.AbstractStructureGenerator = Class.create(Kekule.Calculator.Base, {
            CLASS_NAME: "Kekule.Calculator.AbstractStructureGenerator",
            initProperties: function () {
                this.defineProp("sourceMol", { dataType: "Kekule.StructureFragment", serializable: !1 }),
                    this.defineProp("generatedMol", { dataType: "Kekule.StructureFragment", serializable: !1 }),
                    this.defineProp("childObjMap", { dataType: "Kekule.MapEx", serializable: !1 }),
                    this.defineProp("options", {
                        dataType: DataType.HASH,
                        getter: function () {
                            var e = this.getPropStoreFieldValue("options");
                            return e || ((e = {}), this.setPropStoreFieldValue("options", e)), e;
                        },
                    });
            },
            getGeneratorCoordMode: function () {
                return Kekule.CoordMode.COORD3D;
            },
            done: function () {
                this._modifySourceAccordingToGeneratedMol(
                    this.getSourceMol(),
                    this.getGeneratedMol(),
                    this.getChildObjMap()
                ),
                    this.tryApplySuper("done");
            },
            _modifySourceAccordingToGeneratedMol: function (e, r, t) {
                var i = t;
                if (i) {
                    var a = this.getGeneratorCoordMode(),
                        n = i.getKeys();
                    e.beginUpdate();
                    try {
                        for (var o = 0, s = n.length; o < s; ++o)
                            if (n[o] instanceof Kekule.ChemStructureNode) {
                                var l = n[o],
                                    u = i.get(l).getCoordOfMode(a);
                                l.setCoordOfMode(u, a);
                            }
                    } finally {
                        e.endUpdate();
                    }
                }
            },
        })),
        (Kekule.Calculator.ServiceManager = {
            _serviceInfos: {},
            _getServiceClassInfos: function (r, t) {
                var i = e._serviceInfos[r];
                return !i && t && ((i = []), (e._serviceInfos[r] = i)), i;
            },
            _findServiceClassInfoItemIndex: function (r, t, i) {
                var a = e._getServiceClassInfos(r, !1);
                if (a)
                    for (var n = a.length - 1; n >= 0; --n) {
                        var o = a[n];
                        if (o && !((t && o.serviceClass !== t) || (i && o.id !== i))) return n;
                    }
                return -1;
            },
            register: function (r, t, i, a) {
                var n = e._getServiceClassInfos(r, !0),
                    o = e._findServiceClassInfoItemIndex(r, t);
                o >= 0 && n.splice(o, 1), n.push({ serviceClass: t, id: i, priorityLevel: a || 0 });
            },
            unregister: function (r, t) {
                var i = e._findServiceClassInfoItemIndex(r, t);
                i >= 0 && e._getServiceClassInfos(r, !1).splice(i, 1);
            },
            _getRegisteredServiceInfo: function (r, t) {
                var i = -1,
                    a = null,
                    n = e._getServiceClassInfos(r);
                if (n)
                    for (var o = 0, s = n.length; o < s; ++o) {
                        var l = n[o];
                        if (l) {
                            if (t && l.id === t) {
                                a = l;
                                break;
                            }
                            (!a || l.priorityLevel >= i) && ((a = l), (i = l.priorityLevel));
                        }
                    }
                return a;
            },
            getServiceClass: function (r, t) {
                var i = e._getRegisteredServiceInfo(r, t);
                return i && i.serviceClass;
            },
        });
    var e = Kekule.Calculator.ServiceManager;
    (Kekule.Calculator.Services = { GEN2D: "2D structure generator", GEN3D: "3D structure generator" }),
        (Kekule.Calculator.generateStructure = function (r, t, i, a, n, o) {
            var s = t || Kekule.Calculator.Services.GEN3D,
                l = e.getServiceClass(s);
            if (l) {
                var u,
                    c = new l();
                c.setChildObjMap && ((u = new Kekule.MapEx(!0)), c.setChildObjMap(u));
                var d = function (e) {
                    n && n(e);
                };
                try {
                    c.setSourceMol(r),
                        c.setOptions(i),
                        i && i.sync && c.setAsync(!1),
                        c.execute(
                            function () {
                                a && a(c.getGeneratedMol(), u);
                            },
                            d,
                            function (e) {
                                o && o(e);
                            }
                        );
                } catch (e) {
                    d(e);
                }
                return c;
            }
            var h = Kekule.$L("ErrorMsg.CALC_SERVICE_UNAVAILABLE").format(s);
            return n && n(h), null;
        }),
        (Kekule.Calculator.generate3D = function (e, r, t, i, a) {
            return Kekule.Calculator.generateStructure(e, Kekule.Calculator.Services.GEN3D, r, t, i, a);
        }),
        (Kekule.Calculator.generate2D = function (e, r, t, i, a) {
            return Kekule.Calculator.generateStructure(e, Kekule.Calculator.Services.GEN2D, r, t, i, a);
        });
})();
